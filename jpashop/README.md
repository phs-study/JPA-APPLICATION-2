API 개발 기본
--------------

- 커맨드와 쿼리를 분리하라. 
  - ``Member update(Long id, String name)``
  - 위 함수는 커맨드와 조회가 함께 되고 있음.
  - ``void update(Long id, String name)``
  - 위 함수는 커맨드만 수행함. (조회를 하고 싶다면, 다시 select를 호출하라.)

API 개발 고급
--------------
- Entity를 외부에 노출하지 말라.
  - API 스펙이 Entity에 의존적으로 변하는 문제
  - 양방향 관계에서의 무한 루프
  - Lazy 로딩이 설정된 경우, Jackson 라이브러리가 Proxy 객체를 reflect하지 못함.
  - > 외부 노출용 DTO를 사용하라.

- 지연 로딩에 의한 성능 이슈
  - N + 1 문제
    - 1번째 쿼리의 결과가 N개이고 결과 타입에 지연 로딩 연관관계가 M개일 경우, 최대 1 + N * M 개의 쿼리가 실행됨
      - order 조회 1번
      - order -> member 지연 로딩 조회 
      - order -> delivery 지연 로딩 조회
      - order의 결과가 2개일 경우, 1 + 2 * 2 개의 쿼리 실행(모두 영속성 컨텍스트에 존재하지 않을 때)

- 페치 조인
  - 지연 로딩을 무시하고 연관 관계 Entity를 1번의 쿼리로 가져올 수 있다. 
    - 지연 로딩 연관 관계에 의한 N개의 쿼리 이슈가 발생하지 않음.
    - 적극 활용!

- 쿼리 방식 선택 권장 순서
  - 우선 엔티티를 DTO로 변환하는 방법을 선택한다. 
  - 필요하면 페치 조인으로 성능을 최적화 한다. 대부분의 성능 이슈가 해결된다. 
  - 그래도 안되면 DTO로 직접 조회하는 방법을 사용한다. 
  - 최후의 방법은 JPA가 제공하는 네이티브 SQL이나 스프링 JDBC Template을 사용해서 SQL을 직접 사용한다.

API 개발 고급 - 컬렉션 조회 최적화
  - V1
    - 엔티티 직접 노출
    - 강제 초기화
  - V2
    - 엔티티를 DTO로 변환
    - 강제 초기화
  - V3
    - 페치 조인 최적화
    - 장점
      - 페치 조인으로 SQL이 1번만 실행됨
      - distinct 를 사용한 이유는 1대다 조인이 있으므로 데이터베이스 row가 증가한다. 그 결과 같은 order      엔티티의 조회 수도 증가하게 된다. JPA의 distinct는 SQL에 distinct를 추가하고, 더해서 같은 엔티티가      조회되면, 애플리케이션에서 중복을 걸러준다. 이 예에서 order가 컬렉션 페치 조인 때문에 중복 조회 되는 것을 막아준다.
    - 단점
      - 페이징 불가능 (어플리케이션에서 InMemory Paging을 수행함. 위험!)
  - V3.1
    - 페이징과 한계 돌파
      - 먼저 ToOne(OneToOne, ManyToOne) 관계를 모두 페치조인 한다. ToOne 관계는 row수를 증가시키지 않으므로 페이징 쿼리에 영향을 주지 않는다.
      - 컬렉션은 지연 로딩으로 조회한다.
      - 지연 로딩 성능 최적화를 위해 hibernate.default_batch_fetch_size , @BatchSize 를 적용한다.
      - hibernate.default_batch_fetch_size: 글로벌 설정
      - @BatchSize: 개별 최적화
        - 이 옵션을 사용하면 컬렉션이나, 프록시 객체를 한꺼번에 설정한 size 만큼 IN 쿼리로 조회한다.
      - 장점
          - 쿼리 호출 수가 1 + N -> 1 + 1 로 최적화 된다.
          - 조인보다 DB 데이터 전송량이 최적화 된다. (Order와 OrderItem을 조인하면 Order가 OrderItem 만큼 중복해서 조회된다. 이 방법은 각각 조회하므로 전송해야할 중복 데이터가 없다.)
          - 페치 조인 방식과 비교해서 쿼리 호출 수가 약간 증가하지만, DB 데이터 전송량이 감소한다.
          - 컬렉션 페치 조인은 페이징이 불가능 하지만 이 방법은 페이징이 가능하다.
      - 결론
        - ToOne 관계는 페치 조인해도 페이징에 영향을 주지 않는다. 따라서 ToOne 관계는 페치조인으로 쿼리 수를 줄이고 해결하고, 나머지는 hibernate.default_batch_fetch_size 로 최적화 하자
  - V4
    - JPA에서 DTO 직접 조회
      - Query: 루트 1번, 컬렉션 N 번 실행
      - ToOne(N:1, 1:1) 관계들을 먼저 조회하고, ToMany(1:N) 관계는 각각 별도로 처리한다. 이런 방식을 선택한 이유는 다음과 같다.
        - ToOne 관계는 조인해도 데이터 row 수가 증가하지 않는다.
        - ToMany(1:N) 관계는 조인하면 row 수가 증가한다.
        - row 수가 증가하지 않는 ToOne 관계는 조인으로 최적화 하기 쉬우므로 한번에 조회하고, ToMany 관계는 최적화 하기 어려우므로 findOrderItems() 같은 별도의 메서드로 조회한다.
  - V5
    - Query: 루트 1번, 컬렉션 1번
    - ToOne 관계들을 먼저 조회하고, 여기서 얻은 식별자 orderId로 ToMany 관계인 OrderItem 을 한꺼번에 조회
    - MAP을 사용해서 매칭 성능 향상(O(1))
    - 단점
      - 쿼리는 한번이지만 조인으로 인해 DB에서 애플리케이션에 전달하는 데이터에 중복 데이터가 추가되므로 상황에 따라 V5 보다 더 느릴 수도 있다.
      - 애플리케이션에서 추가 작업이 크다
      - 페이징 불가능

  - 정리
    - 엔티티 조회
      - 엔티티를 조회해서 그대로 반환: V1
      - 엔티티 조회 후 DTO로 변환: V2
      - 페치 조인으로 쿼리 수 최적화: V3
      - 컬렉션 페이징과 한계 돌파: V3.1
      - 컬렉션은 페치 조인시 페이징이 불가능
      - ToOne 관계는 페치 조인으로 쿼리 수 최적화
      - 컬렉션은 페치 조인 대신에 지연 로딩을 유지하고, hibernate.default_batch_fetch_size , @BatchSize 로 최적화
    - DTO 직접 조회
      - JPA에서 DTO를 직접 조회: V4
      - 컬렉션 조회 최적화 - 일대다 관계인 컬렉션은 IN 절을 활용해서 메모리에 미리 조회해서 최적화: V5
      - 플랫 데이터 최적화 - JOIN 결과를 그대로 조회 후 애플리케이션에서 원하는 모양으로 직접 변환: V6
  - 권장 순서
    1. 엔티티 조회 방식으로 우선 접근
       1. 페치조인으로 쿼리 수를 최적화
       2. 컬렉션 최적화
          1. 페이징 필요 hibernate.default_batch_fetch_size , @BatchSize 로 최적화
          2. 페이징 필요X 페치 조인 사용
    2. 엔티티 조회 방식으로 해결이 안되면 DTO 조회 방식 사용
    3. DTO 조회 방식으로 해결이 안되면 NativeSQL or 스프링 JdbcTemplat

OSIV와 성능 최적화
--------
- Open Session In View : 하이버네이트
- Open EntityManager In View: JPA (관례상 OSIV라 한다.)
- <img alt="객체그래프탐색" src ="./doc/img/OSIV_ON.PNG" width ="400" height ="400"/>
- Controller 혹은 View 등 영속성을 단위 쓰레드가 종료될때까지 유지하기 때문에 실시간 트래픽이 중요한 서비스에서는 가용 커넥션이 부족하다.
- <img alt="객체그래프탐색" src ="./doc/img/OSIV_OFF.PNG" width ="400" height ="400"/>
- 커넥션 리소스 낭비가 없는 대신, 지연 로딩을 트랜잭션 안에서만 처리해야 한다.

커맨드와 쿼리 분리
--------
- OSIV를 끈 상태에서 Command와 Query를 분리하여 관리.
    - Command : 핵심 비즈니스 로직(데이터 추가 및 수정 등)
    - Query : 화면이나 API에 맞춘 서비스(주로 읽기 전용 트랜잭션 사용)
    - Command와 Query는 라이프 사이클도 다르므로 분리가 가능하다! 
    - Command는 Query에 비해 덜 자주 바뀐다.

QueryDSL 소개
--------
  - 오..매우 좋음...ㅎ


